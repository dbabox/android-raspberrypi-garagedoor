<html>
<head>
  <title>Readme for the Raspberry Pi garage door code</title>
</head>
<body>
  <h1>Readme for the Raspberry Pi garage door code</h1>
  <p>From the android-raspberrypi-garagedoor Git repository on GitHub</p>
  <p>Opening my garage door using wi-fi from my Android to a Raspberry Pi</p>
  <p>This was inspired by Brad Fitzpatrick's work (<a href="http://brad.livejournal.com/2394220.html" target="_blank">http://brad.livejournal.com/2394220.html</a>)
    that he started in 2008, and the fact that my Flash2Pass stopped working.</p>
  <p>You start the app on your Android phone, and when you drive home and connect to your personal wi-fi network, it asks the Raspberry Pi to open the garage
    door, so you can drive right in without fiddling with anything.</p>
  <p>It uses a Raspberry Pi with the PiFace I/O board and a wi-fi dongle. One of the PiFace relays is used to simulate a garage door pushbutton.</p>
  <p>It uses inetd and a short Python script to avoid the need for a webserver, so it's light on resources. The Pi should be running Raspbian.</p>
  <h3>To set up the Raspberry Pi:</h3>
  <p>(you'll need to do most of this as root, or use sudo)</p>
  <ol>
    <li>Change the hostname to "garagedoor" in raspi-config</li>
    <li>Get the most current list of the latest Raspbian packages by running<br>
      <code>apt-get update</code></li>
    <li>Install the software packages you need by running<br>
      <code>apt-get install openbsd-inetd avahi-daemon python-pifacedigitalio</code></li>
    <li>Copy the garagedoor.service file to /etc/avahi/services</li>
    <li>Create the script user by running<br>
      <code>adduser --system garagedoor</code></li>
    <li>Add the script user to the proper groups (so he can see the PiFace devices) by running<br>
      <code>adduser garagedoor spi</code><br>
      <code>adduser garagedoor gpio</code></li>
    <li>Copy the garagedoor.py file to /usr/local/bin</li>
    <li>Make it an executable script by running<br>
      <code>chmod 500 /usr/local/bin/garagedoor.py</code></li>
    <li>Assign it to the script user by running<br>
      <code>chown garagedoor.nogroup /usr/local/bin/garagedoor.py</code></li>
    <li>Add the inetd entry by running<br>
      <code>update-inetd --add '17000\tstream\ttcp\tnowait\tgaragedoor\t/usr/local/bin/garagedoor.py'</code></li>
    <li>The garage door wires should be inserted in the two relay contacts nearest the jumper, and connected to where you need to connect switches on your
      opener.</li>
    <li>Install a wi-fi dongle as per the HOWTOs on the 'net. You will most probably need a powered USB hub for it, as most dongles are extremely power-hungry.</li>
    <li>Set up your router so that the Raspberry Pi gets a static IP. Somewhere it'll have a screen to say "this IP address is reserved for that MAC address"</li>
  </ol>
  <h3>Testing</h3>
  <p>You should be able to open the garage door by telnetting to port 17000, typing "TOGGLE" and hitting enter.</p>
  <code>
    02:43:37 ~/raspberry_pi # telnet garagedoor.local 17000<br>
    Trying 192.168.128.20...<br>
    Connected to garagedoor.local.<br>
    Escape character is '^]'.<br>
    GARAGEDOOR<br>
    TOGGLE<br>
    DONE<br>
    Connection closed by foreign host.<br>
    02:43:41 ~/raspberry_pi #<br>
  </code>
  <p>If the garage door doesn't open, you should at least hear the relay click. You should also see a line added to /var/log/syslog</p>
  <p>Note that this requires avahi-daemon to be running on your Linux box to resolve "garagedoor.local", but this is usually the case with Debian and Ubuntu.</p>
  <h3>General logic for the setup screen</h3>
  <ul>
    <li>The Raspberry Pi runs avahi-daemon to advertise a "garagedoor" zeroconf service.</li>
    <li>When the user presses "update" we discover this service and resolve the IP address and port.</li>
    <li>We save this in application preferences.</li>
  </ul>
  <h3>General logic for the main app</h3>
  <ul>
    <li>We acquire locks on the wi-fi to keep it running, and on the cpu to keep us running.</li>
    <li>We register a callback to handle connecting to a network, and the results of network scans.</li>
    <li>Now we need to handle scanning for our wi-fi network:
      <ul>
        <li>If we're not connected to wi-fi, or we lose connection, we kick off a network scan.</li>
        <li>When the scan finishes, if we're still not connected, we wait a short while and kick off another network scan.</li>
      </ul>
    </li>
    <li>This handles these cases:
      <ul>
        <li>We're already on our home network and we just want to open/close the garage door. We never start scanning for networks.</li>
        <li>We connect to another wi-fi network, but it's not the home network and doesn't have the Raspberry Pi on it. We don't scan for
        <li>networks until we leave that foreign network, but once we do, we start scanning.</li>
        <li>Wi-fi is turned off. We start a scan, but nothing happens until wi-fi is turned back on, and then it scans and we get results.</li>
      </ul>
    </li>
    <li>All this happens in callbacks, so we don't need to do anything except continuously try to connect to the static IP.</li>
  </ul>
  <h3>General logic for the "away" app</h3>
  <ul>
    <li>We tell the Raspberry Pi our IP address.</li>
    <li>It starts pinging that address.</li>
    <li>When it can't ping the address, it closes the garage door.</li>
  </ul>
  <h3>General logic for the door status app</h3>
  <ul>
    <li>It uses microswitches and the intarwaebz and stuff!</li>
  </ul>
  <h3>Other notes</h3>
  <p>I originally intended to use an Arduino, but a wi-fi shield was $85! The other killer factor was that all the I/O shields were kits and I'm really crap at soldering.</p>
  <p>I thought all the Raspberry Pi buzz was just the usual internet hype, so I never really considered one, but for $35, it was too good to pass up. The MAKE
    Magazine microcontroller guide basically flat out said "out of the dozen boards in this roundup, this or the Arduino are your two good choices" and that was
    a deciding factor.</p>
  <p>It ended up being a full Debian machine not too far behind my previous generation desktop PC.</p>
  <p>I tried to use Avahi/zeroconf/Rendezvous/Bonjour/IPv4LL/mDNS/DNS-SD/NSD/whatever-the-hell-its-called-today to find the Raspberry Pi on the network without
    giving it a static IP address. Unfortunately, when an Android device shuts off the screen and goes to sleep, it loses the ability to receive wi-fi multicast
    packets, meaning zeroconf advertisements are not visible. I do still use it to painlessly fetch the network information for a setup screen.</p>
</body>
</html>
